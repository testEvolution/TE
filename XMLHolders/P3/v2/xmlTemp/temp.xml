<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="" revision="1.0.0" language="Java" filename="H:\Research\TestEvolution\DataAnalysis\pmd-pmd_releases-6.21.0\pmd-pmd_releases-6.21.0\pmd-java\src\test\java\net\sourceforge\pmd\typeresolution\TypeInferenceTest.java"><comment type="block" format="javadoc">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */</comment>

<package>package <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>typeresolution</name></name>;</package>

<import>import static <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>InferenceRuleType</name><operator>.</operator><name>CONTAINS</name></name>;</import>
<import>import static <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>InferenceRuleType</name><operator>.</operator><name>EQUALITY</name></name>;</import>
<import>import static <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>InferenceRuleType</name><operator>.</operator><name>LOOSE_INVOCATION</name></name>;</import>
<import>import static <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>InferenceRuleType</name><operator>.</operator><name>SUBTYPE</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>assertEquals</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>assertNotNull</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>assertNull</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>assertSame</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>assertTrue</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collection</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collections</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Test</name></name>;</import>

<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typedefinition</name><operator>.</operator><name>JavaTypeDefinition</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>Bound</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>BoundOrConstraint</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>Constraint</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>InferenceRuleType</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>TypeInferenceResolver</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>typeinference</name><operator>.</operator><name>Variable</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>testdata</name><operator>.</operator><name>dummytypes</name><operator>.</operator><name>SuperClassA</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>testdata</name><operator>.</operator><name>dummytypes</name><operator>.</operator><name>SuperClassA2</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>testdata</name><operator>.</operator><name>dummytypes</name><operator>.</operator><name>SuperClassAOther</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>typeresolution</name><operator>.</operator><name>testdata</name><operator>.</operator><name>dummytypes</name><operator>.</operator><name>SuperClassAOther2</name></name>;</import>

<class><specifier>public</specifier> class <name>TypeInferenceTest</name> <block>{
    <decl_stmt><decl><type><specifier>private</specifier> <name>JavaTypeDefinition</name></type> <name>number</name> <init>= <expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>Number</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>JavaTypeDefinition</name></type> <name>integer</name> <init>= <expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>Integer</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>JavaTypeDefinition</name></type> <name>primitiveInt</name> <init>= <expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>int</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>JavaTypeDefinition</name></type> <name>generic</name> <init>= <expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>Map</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Variable</name></type> <name>alpha</name> <init>= <expr><operator>new</operator> <call><name>Variable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Variable</name></type> <name>beta</name> <init>= <expr><operator>new</operator> <call><name>Variable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>JavaTypeDefinition</name></type> <name>s</name> <init>= <expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>int</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>JavaTypeDefinition</name></type> <name>t</name> <init>= <expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>double</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testEqualityReduceProperVsProper</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// If S and T are proper types, the constraint reduces to true if S is the same as T (Â§4.3.4), and false</comment>
        <comment type="line">// otherwise.</comment>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertNull</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Otherwise, if S or T is the null type, the constraint reduces to false. TODO</comment>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testEqualityReduceVariableVsNotPrimitive</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// Otherwise, if S is an inference variable, Î±, and T is not a primitive type, the constraint reduces to</comment>
        <comment type="line">// the bound Î± = T.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Bound</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testEqualityReduceNotPrimitiveVsVariable</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// Otherwise, if T is an inference variable, Î±, and S is not a primitive type, the constraint reduces</comment>
        <comment type="line">// to the bound S = Î±.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Bound</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>beta</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>beta</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Bound</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testEqualityReduceSameErasure</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// Otherwise, if S and T are class or interface types with the same erasure, where S has type</comment>
        <comment type="line">// arguments B1, ..., Bn and T has type arguments A1, ..., An, the constraint reduces to the</comment>
        <comment type="line">// following new constraints: for all i (1 â¤ i â¤ n), â¹Bi = Aiâº.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>generic</name></expr></argument>, <argument><expr><name>generic</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testEqualityReduceArrayTypes</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// Otherwise, if S and T are array types, S'[] and T'[], the constraint reduces to â¹S' = T'âº.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>Number</name><index>[]</index></name><operator>.</operator>class</expr></argument>)</argument_list></call></expr></argument>,
                                                        <argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>Integer</name><index>[]</index></name><operator>.</operator>class</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testSubtypeReduceProperVsProper</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// A constraint formula of the form â¹S &lt;: Tâº is reduced as follows:</comment>

        <comment type="line">// If S and T are proper types, the constraint reduces to true if S is a subtype of T (Â§4.10),</comment>
        <comment type="line">// and false otherwise.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>integer</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


        <comment type="line">// Otherwise, if S is the null type, the constraint reduces to true. TODO</comment>

        <comment type="line">// Otherwise, if T is the null type, the constraint reduces to false. TODO</comment>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testSubtypeReduceVariableVsAny</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// Otherwise, if S is an inference variable, Î±, the constraint reduces to the bound Î± &lt;: T.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Bound</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testSubtypeReduceAnyVsVariable</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// Otherwise, if T is an inference variable, Î±, the constraint reduces to the bound S &lt;: Î±.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>integer</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Bound</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>beta</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>beta</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Bound</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>


    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testLooseInvocationProperVsProper</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// A constraint formula of the form â¹S â Tâº is reduced as follows:</comment>

        <comment type="line">// If S and T are proper types, the constraint reduces to true if S is compatible in a loose invocation</comment>
        <comment type="line">// context with T (Â§5.3), and false otherwise.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>LOOSE_INVOCATION</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>integer</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>LOOSE_INVOCATION</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testLooseInvocationLeftBoxing</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// Otherwise, if S is a primitive type, let S' be the result of applying boxing conversion (Â§5.1.7) to S.</comment>
        <comment type="line">// Then the constraint reduces to â¹S' â Tâº.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>primitiveInt</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>LOOSE_INVOCATION</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>LOOSE_INVOCATION</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testLooseInvocationRightBoxing</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// Otherwise, if T is a primitive type, let T' be the result of applying boxing conversion (Â§5.1.7) to T.</comment>
        <comment type="line">// Then the constraint reduces to â¹S = T'âº.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>primitiveInt</name></expr></argument>, <argument><expr><name>LOOSE_INVOCATION</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Otherwise, if T is a parameterized type of the form G&lt;T1, ..., Tn&gt;, and there exists no type of the</comment>
        <comment type="line">// form G&lt;...&gt; that is a supertype of S, but the raw type G is a supertype of S, then the constraint</comment>
        <comment type="line">// reduces to true. TODO</comment>

        <comment type="line">// Otherwise, if T is an array type of the form G&lt;T1, ..., Tn&gt;[]k, and there exists no type of the form</comment>
        <comment type="line">// G&lt;...&gt;[]k that is a supertype of S, but the raw type G[]k is a supertype of S, then the constraint</comment>
        <comment type="line">// reduces to true. (The notation []k indicates an array type of k dimensions.) TODO</comment>

    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testLooseInvocationAnythingElse</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// Otherwise, the constraint reduces to â¹S&lt;:Tâº.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>LOOSE_INVOCATION</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>LOOSE_INVOCATION</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testContainmentReduceTypeVsType</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// A constraint formula of the form â¹S &lt;= Tâº, where S and T are type arguments (Â§4.5.1), is reduced as</comment>
        <comment type="line">// follows:</comment>

        <comment type="line">// If T is a type: // If S is a type, the constraint reduces to â¹S = Tâº.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BoundOrConstraint</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>Constraint</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>CONTAINS</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reduce</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>integer</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// If T is a type: // If S is a wildcard, the constraint reduces to false. TODO</comment>


        <comment type="line">// If T is a wildcard of the form ?, the constraint reduces to true. TODO</comment>

        <comment type="line">// If T is a wildcard of the form ? extends T': TODO</comment>


        <comment type="line">// If T is a wildcard of the form ? super T': TODO</comment>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testIncorporationEqualityAndEquality</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Constraint</name></argument>&gt;</argument_list></name></type> <name>result</name></decl>;</decl_stmt>

        <comment type="line">// ### Original rule 1. : Î± = S and Î± = T imply â¹S = Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Î± = S and T = Î± imply â¹S = Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// S = Î± and Î± = T imply â¹S = Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// S = Î± and T = Î± imply â¹S = Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testIncorporationEqualityAndSubtypeLeftVariable</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Constraint</name></argument>&gt;</argument_list></name></type> <name>result</name></decl>;</decl_stmt>

        <comment type="line">// ### Original rule 2. : Î± = S and Î± &lt;: T imply â¹S &lt;: Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// S = Î± and Î± &lt;: T imply â¹S &lt;: Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Î± &lt;: T and Î± = S imply â¹S &lt;: Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Î± &lt;: T and S = Î± imply â¹S &lt;: Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testIncorporationEqualityAndSubtypeRightVariable</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Constraint</name></argument>&gt;</argument_list></name></type> <name>result</name></decl>;</decl_stmt>

        <comment type="line">// ### Original rule 3. : Î± = S and T &lt;: Î± imply â¹T &lt;: Sâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// S = Î± and T &lt;: Î± imply â¹T &lt;: Sâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// T &lt;: Î± and Î± = S imply â¹T &lt;: Sâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// T &lt;: Î± and S = Î± imply â¹T &lt;: Sâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testIncorporationSubtypeAndSubtype</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Constraint</name></argument>&gt;</argument_list></name></type> <name>result</name></decl>;</decl_stmt>

        <comment type="line">// ### Original rule 4. : S &lt;: Î± and Î± &lt;: T imply â¹S &lt;: Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Î± &lt;: T and S &lt;: Î± imply â¹S &lt;: Tâº</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>incorporationResult</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>EQUALITY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testBoundOrConstraint</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>, <argument><expr><name><name>Constraint</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testErasedCandidateSet</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>JavaTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>types</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>types</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>List</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>types</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>Set</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>erasedCandidate</name> <init>= <expr><call><name><name>TypeInferenceResolver</name><operator>.</operator><name>getErasedCandidateSet</name></name><argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name><name>erasedCandidate</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name><name>erasedCandidate</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>Object</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name><name>erasedCandidate</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>Collection</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name><name>erasedCandidate</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>Iterable</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>emptySet</name> <init>= <expr><call><name><name>TypeInferenceResolver</name><operator>.</operator><name>getErasedCandidateSet</name></name><argument_list>(<argument><expr><name><name>Collections</name><operator>.</operator></name>&lt;<name>JavaTypeDefinition</name><operator>&gt;</operator><call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertNotNull</name><argument_list>(<argument><expr><name>emptySet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>emptySet</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testMinimalErasedCandidateSet</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>minimalSet</name> <init>= <expr><call><name><name>TypeInferenceResolver</name><operator>.</operator><name>getMinimalErasedCandidateSet</name></name><argument_list>(
                <argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>List</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getErasedSuperTypeSet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>minimalSet</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name><name>minimalSet</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>List</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testLeastUpperBound</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>JavaTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>lowerBounds</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lowerBounds</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>SuperClassA</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lowerBounds</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>SuperClassAOther</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lowerBounds</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>SuperClassAOther2</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>SuperClassA2</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>TypeInferenceResolver</name><operator>.</operator><name>lub</name></name><argument_list>(<argument><expr><name>lowerBounds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testResolution</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Bound</name></argument>&gt;</argument_list></name></type> <name>bounds</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>bounds</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>SuperClassA</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>bounds</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Bound</name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>SuperClassAOther</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>SUBTYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>Variable</name></argument>, <argument><name>JavaTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><call><name><name>TypeInferenceResolver</name><operator>.</operator><name>resolveVariables</name></name><argument_list>(<argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name><name>JavaTypeDefinition</name><operator>.</operator><name>forClass</name></name><argument_list>(<argument><expr><name><name>SuperClassA2</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>alpha</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Constraint</name></argument>&gt;</argument_list></name></type> <name>incorporationResult</name><parameter_list>(<parameter><decl><type><name>Bound</name></type> <name>firstBound</name></decl></parameter>, <parameter><decl><type><name>Bound</name></type> <name>secondBound</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Bound</name></argument>&gt;</argument_list></name></type> <name>current</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Bound</name></argument>&gt;</argument_list></name></type> <name>newBounds</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>current</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>firstBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>newBounds</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>secondBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>TypeInferenceResolver</name><operator>.</operator><name>incorporateBounds</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>newBounds</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>


    <function><type><specifier>private</specifier> <name>void</name></type> <name>testBoundOrConstraint</name><parameter_list>(<parameter><decl><type><name>BoundOrConstraint</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>JavaTypeDefinition</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>JavaTypeDefinition</name></type> <name>right</name></decl></parameter>,
                                       <parameter><decl><type><name>InferenceRuleType</name></type> <name>rule</name></decl></parameter>, <parameter><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name> <extends>extends <name>BoundOrConstraint</name></extends></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>assertSame</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>leftProper</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>rightProper</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>ruleType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>


    <function><type><specifier>private</specifier> <name>void</name></type> <name>testBoundOrConstraint</name><parameter_list>(<parameter><decl><type><name>BoundOrConstraint</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>JavaTypeDefinition</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Variable</name></type> <name>right</name></decl></parameter>,
                                       <parameter><decl><type><name>InferenceRuleType</name></type> <name>rule</name></decl></parameter>, <parameter><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name> <extends>extends <name>BoundOrConstraint</name></extends></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>assertSame</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>leftProper</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>rightVariable</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>ruleType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>testBoundOrConstraint</name><parameter_list>(<parameter><decl><type><name>BoundOrConstraint</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>Variable</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>JavaTypeDefinition</name></type> <name>right</name></decl></parameter>,
                                       <parameter><decl><type><name>InferenceRuleType</name></type> <name>rule</name></decl></parameter>, <parameter><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name> <extends>extends <name>BoundOrConstraint</name></extends></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>assertSame</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>leftVariable</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>rightProper</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>ruleType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>testBoundOrConstraint</name><parameter_list>(<parameter><decl><type><name>BoundOrConstraint</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>Variable</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Variable</name></type> <name>right</name></decl></parameter>,
                                       <parameter><decl><type><name>InferenceRuleType</name></type> <name>rule</name></decl></parameter>, <parameter><decl><type><name><name>Class</name><argument_list type="generic">&lt;<argument><name>?</name> <extends>extends <name>BoundOrConstraint</name></extends></argument>&gt;</argument_list></name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>assertSame</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>leftVariable</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>rightVariable</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>.</operator><name>ruleType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
}</block></class>
</unit>
