<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="H:\Research\TestEvolution\DataAnalysis\pmd-pmd_releases-6.21.0\pmd-pmd_releases-6.21.0\pmd-java\src\test\java\net\sourceforge\pmd\lang\java\symboltable\ClassScopeTest.java"><comment type="block" format="javadoc">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */</comment>

<package>package <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>symboltable</name></name>;</package>

<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>assertEquals</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>assertFalse</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>assertTrue</name></name>;</import>
<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>fail</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Iterator</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Test</name></name>;</import>

<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>PMD</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>ast</name><operator>.</operator><name>ASTClassOrInterfaceDeclaration</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>ast</name><operator>.</operator><name>ASTCompilationUnit</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>ast</name><operator>.</operator><name>ASTMethodDeclaration</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>ast</name><operator>.</operator><name>ASTVariableDeclaratorId</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>ast</name><operator>.</operator><name>DummyJavaNode</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>ast</name><operator>.</operator><name>JavaNode</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>symboltable</name><operator>.</operator><name>testdata</name><operator>.</operator><name>InnerClass</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>symboltable</name><operator>.</operator><name>testdata</name><operator>.</operator><name>InnerClass</name><operator>.</operator><name>TheInnerClass</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>java</name><operator>.</operator><name>symboltable</name><operator>.</operator><name>testdata</name><operator>.</operator><name>InnerClass</name><operator>.</operator><name>TheInnerClass</name><operator>.</operator><name>EnumTest</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>symboltable</name><operator>.</operator><name>NameDeclaration</name></name>;</import>
<import>import <name><name>net</name><operator>.</operator><name>sourceforge</name><operator>.</operator><name>pmd</name><operator>.</operator><name>lang</name><operator>.</operator><name>symboltable</name><operator>.</operator><name>NameOccurrence</name></name>;</import>

<class><specifier>public</specifier> class <name>ClassScopeTest</name> <super_list><extends>extends <super><name>BaseNonParserTest</name></super></extends></super_list> <block>{

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testEnumsClassScope</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>java5</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>ENUM_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testEnumTypeParameter</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>java5</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>ENUM_TYPE_PARAMETER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testVarArgsEmpty</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>java5</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"public class Foo {\n"</literal> <operator>+</operator> <literal type="string">"  public void bar1(String s, Integer... i) {}\n"</literal>
                <operator>+</operator> <literal type="string">"  public void bar1() {}\n"</literal> <operator>+</operator> <literal type="string">"  public void c() {\n"</literal> <operator>+</operator> <literal type="string">"    bar1();\n"</literal> <operator>+</operator> <literal type="string">"  }\n"</literal> <operator>+</operator> <literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="line">// FIXME - these will break when this goes from Anonymous$1 to Foo$1</comment>
    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testAnonymousInnerClassName</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ClassNameDeclaration</name></type> <name>classDeclaration</name> <init>= <expr><operator>new</operator> <call><name>ClassNameDeclaration</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ClassScope</name></type> <name>s</name> <init>= <expr><operator>new</operator> <call><name>ClassScope</name><argument_list>(<argument><expr><literal type="string">"Foo"</literal></expr></argument>, <argument><expr><name>classDeclaration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>new</operator> <call><name>ClassScope</name><argument_list>(<argument><expr><name>classDeclaration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Anonymous$1"</literal></expr></argument>, <argument><expr><call><name><name>s</name><operator>.</operator><name>getClassName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>new</operator> <call><name>ClassScope</name><argument_list>(<argument><expr><name>classDeclaration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Anonymous$2"</literal></expr></argument>, <argument><expr><call><name><name>s</name><operator>.</operator><name>getClassName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testContains</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ClassNameDeclaration</name></type> <name>classDeclaration</name> <init>= <expr><operator>new</operator> <call><name>ClassNameDeclaration</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ClassScope</name></type> <name>s</name> <init>= <expr><operator>new</operator> <call><name>ClassScope</name><argument_list>(<argument><expr><literal type="string">"Foo"</literal></expr></argument>, <argument><expr><name>classDeclaration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTVariableDeclaratorId</name></type> <name>node</name> <init>= <expr><operator>new</operator> <call><name>ASTVariableDeclaratorId</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>node</name><operator>.</operator><name>setImage</name></name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>s</name><operator>.</operator><name>addDeclaration</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>VariableNameDeclaration</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>getDeclarations</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>keySet</name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasNext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testCantContainsSuperToString</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ClassNameDeclaration</name></type> <name>classDeclaration</name> <init>= <expr><operator>new</operator> <call><name>ClassNameDeclaration</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ClassScope</name></type> <name>s</name> <init>= <expr><operator>new</operator> <call><name>ClassScope</name><argument_list>(<argument><expr><literal type="string">"Foo"</literal></expr></argument>, <argument><expr><name>classDeclaration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JavaNode</name></type> <name>node</name> <init>= <expr><operator>new</operator> <call><name>DummyJavaNode</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>node</name><operator>.</operator><name>setImage</name></name><argument_list>(<argument><expr><literal type="string">"super.toString"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertFalse</name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>JavaNameOccurrence</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><call><name><name>node</name><operator>.</operator><name>getImage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testContainsStaticVariablePrefixedWithClassName</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ClassNameDeclaration</name></type> <name>classDeclaration</name> <init>= <expr><operator>new</operator> <call><name>ClassNameDeclaration</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ClassScope</name></type> <name>s</name> <init>= <expr><operator>new</operator> <call><name>ClassScope</name><argument_list>(<argument><expr><literal type="string">"Foo"</literal></expr></argument>, <argument><expr><name>classDeclaration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTVariableDeclaratorId</name></type> <name>node</name> <init>= <expr><operator>new</operator> <call><name>ASTVariableDeclaratorId</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>node</name><operator>.</operator><name>setImage</name></name><argument_list>(<argument><expr><literal type="string">"X"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>s</name><operator>.</operator><name>addDeclaration</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>VariableNameDeclaration</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>JavaNode</name></type> <name>node2</name> <init>= <expr><operator>new</operator> <call><name>DummyJavaNode</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>node2</name><operator>.</operator><name>setImage</name></name><argument_list>(<argument><expr><literal type="string">"Foo.X"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>JavaNameOccurrence</name><argument_list>(<argument><expr><name>node2</name></expr></argument>, <argument><expr><call><name><name>node2</name><operator>.</operator><name>getImage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testClassName</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>CLASS_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Foo"</literal></expr></argument>, <argument><expr><call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnclosingScope</name><argument_list>(<argument><expr><name><name>ClassScope</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getClassName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testMethodDeclarationRecorded</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>METHOD_DECLARATIONS_RECORDED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ClassScope</name></type> <name>s</name> <init>= <expr><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>getDeclarations</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>m</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>MethodNameDeclaration</name></type> <name>mnd</name> <init>= <expr><operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>m</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>next</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><call><name><name>mnd</name><operator>.</operator><name>getImage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ASTMethodDeclaration</name></type> <name>node</name> <init>= <expr><operator>(</operator><name>ASTMethodDeclaration</name><operator>)</operator> <call><name><name>mnd</name><operator>.</operator><name>getNode</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getParent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name><name>node</name><operator>.</operator><name>isPrivate</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testTwoMethodsSameNameDiffArgs</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// TODO this won't work with String and java.lang.String</comment>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>METHODS_WITH_DIFF_ARG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getDeclarations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>m</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>&gt;</argument_list></name></type> <name>i</name> <init>= <expr><call><name><name>m</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MethodNameDeclaration</name></type> <name>mnd</name> <init>= <expr><operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>i</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><call><name><name>mnd</name><operator>.</operator><name>getImage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>i</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getImage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>testOneParam</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>ONE_PARAM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getDeclarations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MethodNameDeclaration</name></type> <name>mnd</name> <init>= <expr><operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>m</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>next</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"(String)"</literal></expr></argument>, <argument><expr><call><name><name>mnd</name><operator>.</operator><name>getParameterDisplaySignature</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>testTwoParams</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>TWO_PARAMS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getDeclarations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MethodNameDeclaration</name></type> <name>mnd</name> <init>= <expr><operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>m</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>next</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"(String,int)"</literal></expr></argument>, <argument><expr><call><name><name>mnd</name><operator>.</operator><name>getParameterDisplaySignature</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>testNoParams</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>NO_PARAMS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getDeclarations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MethodNameDeclaration</name></type> <name>mnd</name> <init>= <expr><operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>m</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>next</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"()"</literal></expr></argument>, <argument><expr><call><name><name>mnd</name><operator>.</operator><name>getParameterDisplaySignature</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>testOneParamVararg</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name><name>java5</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>ONE_PARAM_VARARG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getDeclarations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MethodNameDeclaration</name></type> <name>mnd</name> <init>= <expr><operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>m</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>next</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"(String...)"</literal></expr></argument>, <argument><expr><call><name><name>mnd</name><operator>.</operator><name>getParameterDisplaySignature</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>testTwoParamsVararg</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name><name>java5</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>TWO_PARAMS_VARARG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getDeclarations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MethodNameDeclaration</name></type> <name>mnd</name> <init>= <expr><operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>m</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>next</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"(String,String...)"</literal></expr></argument>, <argument><expr><call><name><name>mnd</name><operator>.</operator><name>getParameterDisplaySignature</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testNestedClassesOfImportResolution</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>NESTED_CLASSES_OF_IMPORT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ClassScope</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>EnumTest</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><call><name><name>c</name><operator>.</operator><name>resolveType</name></name><argument_list>(<argument><expr><literal type="string">"TheInnerClass.EnumTest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testNestedClassesResolution</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>java</name><operator>.</operator><name>parseClass</name></name><argument_list>(<argument><expr><name><name>InnerClass</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call>
                                                     <operator>.</operator><call><name>findDescendantsOfType</name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ClassScope</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>InnerClass</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><call><name><name>c</name><operator>.</operator><name>resolveType</name></name><argument_list>(<argument><expr><literal type="string">"InnerClass"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>TheInnerClass</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><call><name><name>c</name><operator>.</operator><name>resolveType</name></name><argument_list>(<argument><expr><literal type="string">"InnerClass.TheInnerClass"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>TheInnerClass</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><call><name><name>c</name><operator>.</operator><name>resolveType</name></name><argument_list>(<argument><expr><literal type="string">"TheInnerClass"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Within this scope, we can access it directly</comment>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testImportNestedClassesResolution</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>IMPORT_NESTED_CLASSES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ClassScope</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>EnumTest</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><call><name><name>c</name><operator>.</operator><name>resolveType</name></name><argument_list>(<argument><expr><literal type="string">"EnumTest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>testNestedClassDeclFound</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>NESTED_CLASS_FOUND</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ClassScope</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><call><name><name>c</name><operator>.</operator><name>getDeclarations</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ClassNameDeclaration</name></type> <name>cnd</name> <init>= <expr><operator>(</operator><name>ClassNameDeclaration</name><operator>)</operator> <call><name><name>m</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call><operator>.</operator><call><name>next</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Buz"</literal></expr></argument>, <argument><expr><call><name><name>cnd</name><operator>.</operator><name>getImage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>testbuz</name><parameter_list>()</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>parseCode</name><argument_list>(<argument><expr><name>METH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// SymbolTableViewer st = new SymbolTableViewer();</comment>
        <comment type="line">// acu.jjtAccept(st, null);</comment>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testMethodUsageSeen</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>METHOD_USAGE_SEEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getDeclarations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>i</name> <init>= <expr><call><name><name>m</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MethodNameDeclaration</name></type> <name>mnd</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name></decl>;</decl_stmt>

        <do>do <block>{<block_content>
            <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name><name>i</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mnd</name> <operator>=</operator> <operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name><name>mnd</name><operator>.</operator><name>getImage</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></type> <name>usages</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>usages</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>JavaNameOccurrence</name><operator>)</operator> <call><name><name>usages</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>.</operator><call><name>getImage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testMethodUsageSeenWithThis</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>METHOD_USAGE_SEEN_WITH_THIS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getDeclarations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>i</name> <init>= <expr><call><name><name>m</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MethodNameDeclaration</name></type> <name>mnd</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name></decl>;</decl_stmt>

        <do>do <block>{<block_content>
            <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name><name>i</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mnd</name> <operator>=</operator> <operator>(</operator><name>MethodNameDeclaration</name><operator>)</operator> <call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name><name>mnd</name><operator>.</operator><name>getImage</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></type> <name>usages</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>usages</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>JavaNameOccurrence</name><operator>)</operator> <call><name><name>usages</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>.</operator><call><name>getImage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testMethodUsageSeen2</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>METHOD_USAGE_SEEN2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTClassOrInterfaceDeclaration</name></type> <name>n</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>findDescendantsOfType</name></name><argument_list>(<argument><expr><name><name>ASTClassOrInterfaceDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ClassScope</name><operator>)</operator> <call><name><name>n</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><call><name>getDeclarations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>m</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>NameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>m</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"baz"</literal></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getImage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNode</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLine</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// this is the public method declaration - it is not used</comment>
                <comment type="line">// anywhere</comment>
                <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNode</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLine</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// this is the private (overloaded) method</comment>
                <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// it's used once in line 3</comment>
                <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getLocation</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLine</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"unexpected name declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Test case for bug report #2410201
     */</comment>
    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testNestedClassFieldAndParameter</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>NESTED_CLASS_FIELD_AND_PARAM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ASTMethodDeclaration</name></type> <name>node</name> <init>= <expr><call><name><name>acu</name><operator>.</operator><name>getFirstDescendantOfType</name></name><argument_list>(<argument><expr><name><name>ASTMethodDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>VariableNameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>vd</name> <init>= <expr><call><name><name>node</name><operator>.</operator><name>getScope</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDeclarations</name><argument_list>(<argument><expr><name><name>VariableNameDeclaration</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>vd</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>paramCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>VariableNameDeclaration</name></argument>, <argument><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>vd</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDeclaratorId</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isFormalParameter</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getImage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>NameOccurrence</name></argument>&gt;</argument_list></name></type> <name>occurrences</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>occurrences</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>NameOccurrence</name></type> <name>no1</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><call><name><name>no1</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLine</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>NameOccurrence</name></type> <name>no2</name> <init>= <expr><call><name><name>occurrences</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><call><name><name>no2</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLine</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>paramCount</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>paramCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Test</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>testNullType</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>ASTCompilationUnit</name></type> <name>acu</name> <init>= <expr><call><name>parseCode</name><argument_list>(<argument><expr><name>TEST_NULL_TYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    </block_content>}</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>NESTED_CLASS_FIELD_AND_PARAM</name> <init>= <expr><literal type="string">"public class Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" class Test {"</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"   public String field;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"   public Test t;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">" public void foo(String field) {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"   Test t = new Test();"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"   t.field = field;"</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"   t.t.field = field;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>METHOD_USAGE_SEEN2</name> <init>= <expr><literal type="string">"public class Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" public void baz() {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"  baz(x, y);"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" private void baz(int x, int y) {}"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>METHOD_USAGE_SEEN</name> <init>= <expr><literal type="string">"public class Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" private void bar() {}"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">" public void buz() {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  bar();"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>METHOD_USAGE_SEEN_WITH_THIS</name> <init>= <expr><literal type="string">"public class Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" private void bar() {}"</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" public void buz() {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  this.bar();"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>METH</name> <init>= <expr><literal type="string">"public class Test {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  static { "</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"   int y; "</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  } "</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  void bar(int x) {} "</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  void baz(int x) {} "</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>NESTED_CLASS_FOUND</name> <init>= <expr><literal type="string">"public class Test {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  private class Buz {} "</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ONE_PARAM</name> <init>= <expr><literal type="string">"public class Test {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  void bar(String x) {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  }"</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>TWO_PARAMS</name> <init>= <expr><literal type="string">"public class Test {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  void bar(String x, int y) {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"  }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>NO_PARAMS</name> <init>= <expr><literal type="string">"public class Test {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  void bar() {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  }"</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ONE_PARAM_VARARG</name> <init>= <expr><literal type="string">"public class Test {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  void bar(String... s) {"</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>TWO_PARAMS_VARARG</name> <init>= <expr><literal type="string">"public class Test {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"  void bar(String s1, String... s2) {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>CLASS_NAME</name> <init>= <expr><literal type="string">"public class Foo {}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>METHOD_DECLARATIONS_RECORDED</name> <init>= <expr><literal type="string">"public class Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" private void bar() {}"</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>METHODS_WITH_DIFF_ARG</name> <init>= <expr><literal type="string">"public class Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">" private void bar(String x) {}"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" private void bar() {}"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ENUM_SCOPE</name> <init>= <expr><literal type="string">"public enum Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" HEAP(\"foo\");"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">" private final String fuz;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">" public String getFuz() {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"  return fuz;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">" }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>TEST_NULL_TYPE</name> <init>= <expr><literal type="string">"public abstract class NullTypeTest {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"   protected Comparator&lt;TreeNode&gt; nodesComparator = (o1, o2) -&gt; StringHelper.saveCompare(getFilterableString(o1), getFilterableString(o2));"</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"   public abstract String getFilterableString(TreeNode node);"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ENUM_TYPE_PARAMETER</name> <init>= <expr><literal type="string">"public enum Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"   BAR(isCustomer(BazEnum.FOO_BAR));"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"   Foo(boolean isCustomer) { }"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"   private static boolean isCustomer(BazEnum baz) {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"      return false;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"   }"</literal>
            <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name> <operator>+</operator> <literal type="string">"}"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>IMPORT_NESTED_CLASSES</name> <init>=
            <expr><literal type="string">"import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass.EnumTest;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"public class Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">" public EnumTest e;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"}"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>NESTED_CLASSES_OF_IMPORT</name> <init>=
            <expr><literal type="string">"import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"public class Foo {"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">" public TheInnerClass.EnumTest e;"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name>
            <operator>+</operator> <literal type="string">"}"</literal> <operator>+</operator> <name><name>PMD</name><operator>.</operator><name>EOL</name></name></expr></init></decl>;</decl_stmt>
}</block></class>
</unit>
